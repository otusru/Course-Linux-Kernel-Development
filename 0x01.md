# Курс: Разработка ядра Linux

---

## Часть 1: Введение в ядро Linux

**Рекомендуемое время:** 6 часов

### Темы:

* Что такое ядро Linux?
* История и эволюция ядра Linux
* Лицензирование и сообщество разработчиков
* Архитектура ядра: монолитное ядро
* Роль ядра в операционной системе
* Основные компоненты ядра Linux
* Процесс загрузки системы и роль ядра
* Установка и настройка Linux для разработки ядра
* Обзор и структура исходного кода ядра Linux

### Лабораторные задания:

* Установка Linux и настройка окружения для разработки ядра
* Загрузка исходного кода ядра
* Ознакомление со структурой исходников и составление краткого отчёта

### Чек-лист:

* [ ] Установлена и настроена Linux-система для разработки ядра
* [ ] Исходный код ядра успешно загружен
* [ ] Понимается базовая структура исходного кода
* [ ] Составлен отчет по ключевым компонентам ядра

---

## Часть 2: Основы разработки модулей ядра

**Рекомендуемое время:** 8 часов

### Темы:

* Что такое модули ядра?
* Создание и сборка простого модуля ядра
* Загрузка/выгрузка модулей, использование printk
* Макросы \_\_init и \_\_exit
* Передача параметров командной строки
* Модули из нескольких файлов
* Makefile для модулей
* Документирование модулей
* Отладка модулей с dmesg

### Лабораторные задания:

* Создать и собрать простой модуль "Hello World"
* Использовать параметры командной строки
* Создать модуль из нескольких файлов
* Настроить Makefile
* Отладить модуль и проанализировать логи dmesg

### Чек-лист:

* [ ] Модуль создан и успешно загружен в ядро
* [ ] Параметры командной строки работают корректно
* [ ] Makefile работает с несколькими исходниками
* [ ] Логи printk отображаются в dmesg
* [ ] Модуль корректно выгружается

---

## Часть 3: Основы системного программирования

**Рекомендуемое время:** 10 часов

### Темы:

* Системные вызовы Linux
* Создание и управление процессами
* Планирование процессов и приоритеты
* Управление памятью в пользовательском пространстве
* Работа с файлами через системные вызовы
* Обработка сигналов
* Межпроцессное взаимодействие (IPC)
* Потоки и синхронизация
* Обработка ошибок
* Отладка с gdb

### Лабораторные задания:

* Создать программу с несколькими процессами
* Использовать системные вызовы для файловых операций
* Реализовать обработчики сигналов
* Применить межпроцессное взаимодействие (пайпы, сокеты)
* Написать многопоточное приложение с mutex
* Отладить приложение через gdb

### Чек-лист:

* [ ] Программа использует fork()
* [ ] Системные вызовы для работы с файлами применены
* [ ] Сигналы корректно обрабатываются
* [ ] IPC работает между процессами
* [ ] Потоки и синхронизация реализованы
* [ ] Произведена успешная отладка через gdb

---

## Часть 4: Разработка драйверов устройств

**Рекомендуемое время:** 12 часов

### Темы:

* Что такое драйверы устройств?
* Типы драйверов: символьные, блочные, сетевые
* Создание драйвера символьного устройства
* Структура file\_operations и её использование
* Регистрация и удаление устройств
* Операции чтения и записи
* Управление устройствами через ioctl
* Работа с буферами и кэшированием данных
* Обработка ошибок в драйверах
* Тестирование и отладка драйверов

### Лабораторные задания:

* Создать символьный драйвер устройства "Hello Device"
* Реализовать file\_operations: open, read, write, release
* Реализовать ioctl команды для управления устройством
* Протестировать драйвер с помощью пользовательской программы
* Отладить драйвер, используя printk и dmesg
* Обработать ошибки и проверить корректность выгрузки драйвера

### Чек-лист:

* [ ] Символьный драйвер успешно компилируется и загружается
* [ ] Реализованы основные методы file\_operations
* [ ] ioctl команды корректно обрабатываются
* [ ] Пользовательская программа взаимодействует с драйвером
* [ ] Драйвер устойчив к ошибкам и корректно выгружается

---

## Часть 5: Архитектура ядра Linux

**Рекомендуемое время:** 14 часов

### Темы:

* Общий обзор архитектуры ядра
* Инициализация ядра и процесс загрузки
* Управление процессами: task\_struct и планировщик
* Механизмы синхронизации: spinlocks, семафоры, mutexes
* Обработка прерываний и исключений
* Управление памятью в ядре: kmalloc, vmalloc, mmap
* Основные структуры данных ядра: списки, хеш-таблицы, деревья
* Виртуальная файловая система (VFS)
* Блочный и символьный ввод/вывод
* Сетевой стек ядра

### Лабораторные задания:

* Анализ структуры task\_struct в исходниках ядра
* Реализация примера использования spinlock
* Работа с kmalloc и vmalloc: написание кода выделения и освобождения памяти
* Исследование работы VFS на простом примере
* Просмотр логов сетевого стека ядра

### Чек-лист:

* [ ] Понимание процесса инициализации ядра
* [ ] Реализованы и протестированы синхронизационные примитивы
* [ ] Понимание структуры task\_struct
* [ ] Понимание и работа с памятью ядра
* [ ] Знакомство с VFS и файловыми операциями в ядре

---

## Часть 6: Работа с прерываниями и таймерами

**Рекомендуемое время:** 10 часов

### Темы:

* Аппаратные прерывания и обработчики
* Регистрация/удаление обработчиков прерываний
* Softirq и tasklets
* Таймеры в ядре Linux
* Синхронизация в обработчиках прерываний
* Workqueues для отложенных задач
* Отладка прерываний и таймеров
* Многозадачность и планирование
* Приоритеты задач и реализация систем реального времени

### Лабораторные задания:

* Написать обработчик аппаратного прерывания (например, для виртуального устройства)
* Использовать softirq и tasklets для отложенной обработки
* Реализовать таймер и проверить его работу
* Использовать workqueue для выполнения задач в контексте процесса
* Настроить приоритеты задач и проследить поведение планировщика

### Чек-лист:

* [ ] Реализован и отлажен обработчик прерываний
* [ ] Использованы softirq/tasklets и workqueues
* [ ] Таймеры корректно запускаются и завершаются
* [ ] Продемонстрирована работа планировщика с приоритетами
* [ ] Понимание механизмов синхронизации при прерываниях

---

## Часть 7: Управление памятью в ядре

**Рекомендуемое время:** 12 часов

### Темы:

* Структуры управления памятью: page, slab, buddy
* Выделение и освобождение памяти: kmalloc, vmalloc
* Управление страницами памяти и свопинг
* Перераспределение памяти, дефрагментация
* Использование percpu-данных
* Механизмы кэширования и буферизации
* Обработка ошибок при управлении памятью
* Оптимизация использования памяти
* Инструменты мониторинга памяти (vmstat, slabtop)
* Отладка проблем с памятью

### Лабораторные задания:

* Написать модуль, демонстрирующий работу kmalloc/vmalloc
* Исследовать и проанализировать работу buddy allocator
* Использовать percpu-память в примере модуля
* Профилировать использование памяти с помощью slabtop
* Реализовать простой механизм кэширования в модуле

### Чек-лист:

* [ ] Работа kmalloc и vmalloc изучена и продемонстрирована
* [ ] Понимание механизмов распределения страниц
* [ ] Реализовано и протестировано использование percpu-данных
* [ ] Понимание и использование инструментов мониторинга памяти
* [ ] Оптимизировано использование памяти в примерах

---

## Часть 8: Безопасность ядра и защита системы

**Рекомендуемое время:** 10 часов

### Темы:

* Основы безопасности в Linux-ядре
* Пространства имён (namespaces) и cgroups как изоляционные механизмы
* Linux Security Modules (LSM)
* SELinux: архитектура и принципы
* AppArmor и сравнение с SELinux
* Seccomp и ограничение системных вызовов
* Защита памяти: NX, SMEP, SMAP
* KASLR: Address Space Layout Randomization
* Проверка целостности ядра (IMA, integrity subsystem)
* Работа с /dev/mem и защита от прямого доступа

### Лабораторные задания:

* Настроить и протестировать SELinux профили на примере
* Исследовать работу cgroups и namespaces, изолировать процессы
* Написать простой LSM-модуль (или использовать существующий для изучения)
* Использовать seccomp для ограничения системных вызовов пользовательского процесса
* Проверить защиту памяти с помощью настроек ядра и соответствующих инструментов
* Изучить механизм проверки целостности ядра с помощью IMA

### Чек-лист:

* [ ] Настроен SELinux, проверена работа политик
* [ ] Реализована изоляция с помощью namespaces и cgroups
* [ ] Изучен и протестирован LSM-модуль
* [ ] Seccomp ограничивает системные вызовы по заданной политике
* [ ] Проверены и поняты механизмы защиты памяти и целостности ядра

---

## Часть 9: Продвинутые механизмы ядра

**Рекомендуемое время:** 12 часов

### Темы:

* eBPF (Extended Berkeley Packet Filter)
* Создание и загрузка eBPF-программ
* Использование eBPF для трассировки ядра (bpftrace, perf)
* Control Groups (cgroups) версии 1 и 2
* Namespaces: mount, pid, net, ipc, user, uts
* Контейнеры и взаимодействие с ядром (LXC, Docker)
* Подсистема аудита ядра (auditd)
* Live patching ядра: kpatch, kgraft
* Инструменты анализа ядра: ftrace, perf, kdump
* Трассировка системных вызовов и событий ядра

### Лабораторные задания:

* Написать и загрузить простую eBPF программу для мониторинга системных вызовов
* Использовать bpftrace для трассировки функций ядра
* Настроить cgroups v2 и ограничить ресурсы процессов
* Создать изолированное окружение с namespaces и запустить контейнер
* Анализировать логи с auditd и фильтровать события безопасности
* Сделать live patch для ядра и протестировать его работу
* Использовать perf и ftrace для сбора данных о производительности ядра

### Чек-лист:

* [ ] Созданы и отлажены eBPF программы
* [ ] Использованы bpftrace и perf для трассировки
* [ ] Настроены и протестированы cgroups v2
* [ ] Созданы и запущены процессы в namespaces и контейнерах
* [ ] Анализ логов auditd выполнен
* [ ] Live patch успешно применён и проверен

---

## Часть 10: Разработка и вклад в ядро

**Рекомендуемое время:** 10 часов

### Темы:

* Как работает процесс разработки ядра Linux
* Подсистемы ядра и роль мейнтейнеров
* Работа с git, git-bisect, git-send-email
* Написание патчей и соответствие code style (checkpatch.pl)
* Работа с документацией ядра (Documentation/)
* Использование coccinelle для анализа и трансформаций кода
* Подготовка изменений: от идеи до RFC
* Отправка патча в LKML и процесс review
* Поддержка и сопровождение своего кода
* Участие в сообществе, Open Source карьера, менторство

### Лабораторные задания:

* Склонировать репозиторий ядра и сделать базовые операции git
* Найти баг с помощью git-bisect
* Написать патч с исправлением и проверить стиль кода checkpatch.pl
* Использовать coccinelle для поиска проблем в коде
* Подготовить RFC и отправить патч в тестовую ветку (симуляция)
* Организовать code review с одногруппниками
* Создать личный профиль в LKML и описать участие в проекте

### Чек-лист:

* [ ] Выполнены операции git и git-bisect
* [ ] Написан и проверен патч с помощью checkpatch.pl
* [ ] Использован coccinelle для анализа кода
* [ ] Подготовлена документация к патчу
* [ ] Отправлен патч и организован review
* [ ] Ознакомление с процессом участия в сообществе

---
