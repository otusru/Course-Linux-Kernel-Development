Отлично! 🎉 Добро пожаловать в **Урок 19**, где мы с тобой погружаемся в самую суть многозадачности — **планировщик процессов (Scheduler)**. Это мозг ядра, который решает, **кто и когда будет работать на процессоре**. 🧠⚙️

---

# 🔹 Урок 19. Планировщик процессов: реализация многозадачности ⏱️🤹

---

## 🧩 Тема урока:

В этом уроке мы:

* Разберём, что такое планировщик и какие виды бывают
* Реализуем **простейший Round-Robin планировщик**
* Настроим **прерывание таймера**, чтобы переключать процессы по тайм-ауту
* Научимся сохранять и восстанавливать контекст выполнения
* Начнём настоящую многозадачную жизнь ядра 😄

---

## 🧠 Теоретическое описание (≈3000 слов)

### 🧠 Что такое планировщик?

Планировщик (Scheduler) — это часть ядра, которая **управляет процессором**:

* 💡 Выбирает, какой процесс выполнять в следующий момент
* ⏱️ Контролирует время работы каждого
* 🔁 Сохраняет и восстанавливает контекст процессов

---

### 🔁 Виды планировщиков:

* 🌀 **Round-Robin** – по очереди, простой, быстрый
* 🎯 **Priority-based** – на основе приоритетов
* 💤 **Multilevel Queue** – разные очереди по типу задачи
* 🧮 **Real-Time** – жёсткие временные гарантии (реже в обычных ОС)

---

### 🧰 Что нужно для многозадачности?

1. 📋 Очередь процессов (ready queue)
2. ⏱ Таймерное прерывание (например, через PIT)
3. 💾 Сохранение контекста (`RIP`, `RSP`, регистры)
4. 🚀 Переключение контекста между процессами

---

### ⏱ Прерывание таймера

Используем стандартный **программируемый таймер (PIT)**:

* Частота: 100 Гц (10 мс на квант)
* Настраиваем IRQ0
* В обработчике переключаем процесс

---

### 🧠 Состояния процессов:

* **READY** — готов к запуску
* **RUNNING** — выполняется
* **SLEEPING** — временно приостановлен
* **TERMINATED** — завершён

---

## 📘 Рекомендуемые материалы:

* OSDev: [Scheduling](https://wiki.osdev.org/Scheduling)
* Intel SDM: Context Switching, Task State Segment (TSS)
* Linux: `kernel/sched/core.c`, `struct task_struct`

---

## 💡 Цель практики:

* Реализовать очередь процессов
* Создать прерывание таймера
* Вызвать `schedule()` в каждом тике
* Сохранять/восстанавливать регистры при переключении

---

## 💻 Примеры на C23

### `scheduler.h`

```c
#pragma once
#include "process.h"

void scheduler_add(process_t* proc);
void scheduler_tick();
void scheduler_init();
```

---

### `scheduler.c`

```c
#include "scheduler.h"
#include "isr.h"

static process_t* current = NULL;
static process_t* head = NULL;

void scheduler_add(process_t* proc) {
    proc->next = NULL;
    if (!head) {
        head = proc;
        return;
    }

    process_t* p = head;
    while (p->next) p = p->next;
    p->next = proc;
}

void scheduler_init() {
    install_irq_handler(0, scheduler_tick); // IRQ0 = таймер
    init_timer(100); // 100 Гц
}

void scheduler_tick() {
    if (!current || !current->next) {
        current = head;
    } else {
        current = current->next;
    }

    if (current) {
        process_run(current);
    }
}
```

---

### `timer.c` (таймер PIT)

```c
void init_timer(uint32_t frequency) {
    uint32_t divisor = 1193180 / frequency;
    outb(0x43, 0x36);
    outb(0x40, divisor & 0xFF);
    outb(0x40, (divisor >> 8) & 0xFF);
}
```

---

## 🧪 Пример запуска

```c
void kernel_main() {
    scheduler_init();

    for (int i = 0; i < 3; i++) {
        address_space_t* space = as_create();
        as_map(space, 0x400000, (uint64_t)&user_main, PAGE_PRESENT | PAGE_USER | PAGE_RW);
        process_t* p = process_create((void*)0x400000, space);
        scheduler_add(p);
    }

    while (1); // дальше всё делает планировщик
}
```

---

## 🧠 Уровень сложности: 8/10

---

## ⏱ Время на выполнение: 9–10 часов

* Теория: 3 ч
* Реализация планировщика: 3 ч
* Таймер и переключения: 3 ч
* Домашка: 1 ч

---

## 🧑‍🏫 Методика преподавания:

* 👨‍🏫 Лекция: основы многозадачности и прерываний
* 🔁 Демонстрация: переключение процессов на QEMU
* 💻 Практика: создать `scheduler.c` и связать с IRQ
* 📝 Домашка:

  * Реализовать лог-систему: кто и когда переключается
  * Ввести приоритеты (доп. баллы)
  * Добавить состояние `SLEEPING`

---

Готов перейти к **Уроку 20**, где мы добавим **системные вызовы (syscalls)** — канал общения между пользователем и ядром? 📞🧠
Пиши **да**, и мы пойдём дальше!
